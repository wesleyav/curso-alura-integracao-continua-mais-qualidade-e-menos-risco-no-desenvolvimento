"Integração contínua (CI) é uma prática de desenvolvimento que requer que os desenvolvedores integrem o código em um repositório compartilhado várias vezes ao dia."

#################################################

Sistema de controle de versão

- ferramenta não importa
- comita tudo necessário para construção do projeto
	- código
	- scripts
	- migrações, schemas
	- IDE configs
	- não comita o que pode ser contruído (gem, jar, image, modules)
	- clone e começar (deve ser fácil)

#################################################

Organização dos repositórios

- cada projeto em seu repositório (Multi-repo)
- cada projeto no mesmo repositório (Mono-repo)

#################################################

- Integração Contínua (CI) significa integrar as alterações no mainline (master ou trunk) diariamente

- Para usar Integração Contínua, é necessário usar um sistema de controle de versão (VCS), e no final integramos o código no repositório (usar Git não é obrigatório)

- Aplicando Integração Contínua corretamente, diminuímos os problemas de integração (como merge hell), melhoramos a comunicação entre desenvolvedores e antecipamos a descoberta de bugs

- Os estilos de organização de projeto
	- Mono-repo possui todos os projetos em um único repositório
	- Multi-repo separa um repositório para cada projeto

#################################################

Ramificações

trunk based development
git flow
github flow
one flow
feature branch flow
pull request flow
gitlab flow

"Everyone commits To the Mainline every day." - Martin Fowler

- A regra da integração continua é antecipar os problemas. A princípio, o branch pode ser um perigo, um ampliador de risco. Existem alguams regras que podemo minimizar esse risco:

- commits simples e releaseble, orientados à uma tarefa

- branches de vida curta, margens mais simples

- estratégia combinada pela equipe

#################################################

Alguns branching models famosos são:

- Temporários (branches locais) São branches localizados apenas na máquina local e deverão se extiguir, são utilizados para organizar fluxos de trabalho e depois realizar o commit.

- Feature Branches São utilizados para implementar funcionalidades ou orientar tarefas.

- Historical Branches (mastaer e develop) As alterações ficam organizadas em commits baseados na cronologia no caso de um projeto de software.

- Environment Branches (Staging e Production)] Existem branches que são baseados no ambiente, isto é, em que espaço é realizado o deploy.

- Maintenance Branches (Release e Hotfix) Temos, ainda, os branches de manutenção do sistema.


- trunk based development -> https://trunkbaseddevelopment.com/

Complexidade (1 - fácil, 5 - difícil)
1 - trunk based development
2 - feature branch
3 - github flow
4 - gitlab flow
5 - git flow

#################################################

Como evitar branches de vida longa?

Feature Flags e Branch by Abastraction

- Feature flags: Suponhamos uma nova funcionalidade em nosso projeto que terá um tempo longo de implementação. Contudo, não queremos criar uma nova ramificação para esse processo, queremos trabalhar diretamente com o master ainda que o código não esteja completo.

Anteriormente, comentamos que cada commit deve ser releaseble, isto é, pode ser publicado. Existe uma maneira de trabalhar sem branches: a feature flag.

O código é inserido no master, mas ele não é visível para a equipe. O Feature flag server também para testar funcionalidades, por exemplo.

- Branch by Abastraction: apesar do nome, não envolve a criação de uma nova ramificação. Temos um módulo ligado, uma parte da aplicação utiliza uma biblioteca antiga e precisa ser substituída. Esse é um processo lento, e muitos elementos precisam ser alterados.

O primeiro passo é introduzir uma abstração no código principal, isto é, uma camada intermediária para isolar o código que utiliza o módulo, portanto todas as chamadas deverão passar pela camada de abstração. Essa camada pode ser uma interface, várias ou mesmo uma classe que realiza delegações.

Uma vez que é aplicada essa técnica de desacoplamento, podemos gradativamente a re-implementação. Podemos utilizar um módulo legado para o que é de fato utilizava o módulo antigo.

modulo

Com o tempo, o módulo antigo fica em desuso e pode ser suprimido completamente.

#################################################

Como sincronizr branches?

- Merge
- Rebase

#################################################

Para saber mais: Fontes externas

Seguem alguns links externos das estratégias mencionadas:

https://trunkbaseddevelopment.com/
https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow
https://guides.github.com/introduction/flow/
https://docs.gitlab.com/ee/topics/gitlab_flow.html
https://danielkummer.github.io/git-flow-cheatsheet/index.pt_BR.html

#################################################

O que aprendemos?

- O Git possui branches leves, que causou a criação de workflows baseado em branches
- Existem vários flows ou modelos de ramificação (branching model)
- Alguns dos modelos conhecidos são:
	- Trunk-Based
	- Feature Branch Flow
	- GitHub Flow
	- GitLab Flow
	- Git Flow
- Cada um define a semântica e uso da branch
- lembre-se, cada branch deve ser de vida curta para diminuir o risco do merge hell
- O comando rebase garante um histórico linear dos commits
- Rebase não deve ser usado em branches compartilhadas/públicas

#################################################